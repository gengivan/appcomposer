// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.ut = window.ut || {};

  window.ut.tools = window.ut.tools || {};

  window.ut.tools.conceptmapper = window.ut.tools.conceptmapper || {};

  window.ut.tools.conceptmapper.ConceptMapper = (function() {
    function ConceptMapper(configurationUrl) {
      this.setConceptMapFromJSON = __bind(this.setConceptMapFromJSON, this);
      this.loadConceptMap = __bind(this.loadConceptMap, this);
      this.saveConceptMap = __bind(this.saveConceptMap, this);
      this.deleteConnectionsBetween = __bind(this.deleteConnectionsBetween, this);
      this.connectionExists = __bind(this.connectionExists, this);
      this.onClickEdgeHandler = __bind(this.onClickEdgeHandler, this);
      this.setConceptLinkMode = __bind(this.setConceptLinkMode, this);
      this.setConceptNodeMode = __bind(this.setConceptNodeMode, this);
      this.deleteAll = __bind(this.deleteAll, this);
      this.onClickHandlerTrashcan = __bind(this.onClickHandlerTrashcan, this);
      this.removeConcept = __bind(this.removeConcept, this);
      this.onBlurHandlerInjectParagraph = __bind(this.onBlurHandlerInjectParagraph, this);
      this.onBlurHandlerInjectRelation = __bind(this.onBlurHandlerInjectRelation, this);
      this.onClickHandlerConnectionLabel = __bind(this.onClickHandlerConnectionLabel, this);
      this.onClickHandlerInjectCombobox = __bind(this.onClickHandlerInjectCombobox, this);
      this.onClickHandlerInjectTextarea = __bind(this.onClickHandlerInjectTextarea, this);
      this._initJsPlumb = __bind(this._initJsPlumb, this);
      this._initDnD = __bind(this._initDnD, this);
      this.notificationPremise = __bind(this.notificationPremise, this);
      this._init = __bind(this._init, this);
      this._logAction = __bind(this._logAction, this);
      this.consumeNotification = __bind(this.consumeNotification, this);
      this.configure = __bind(this.configure, this);
      console.log("Initializing ConceptMapper0.9.");
      this.meta = {
        "target": {
          "objectType": "conceptMap",
          "id": ut.commons.utils.generateUUID(),
          "displayName": "unnamed concept map"
        },
        "generator": {
          "objectType": "application",
          "url": document.URL,
          "id": ut.commons.utils.generateUUID(),
          "displayName": "ut.tools.conceptmapper"
        }
      };
      this.LINK_MODE = "link_mode";
      this.NODE_MODE = "node_mode";
      this.mode = this.NODE_MODE;
      this.isCurrentlyLogging = true;
      this.sourceNode = void 0;
      this.targetNode = void 0;
      this.editingLabel = void 0;
      this.storage = void 0;
      this.actionLogger = new ut.commons.actionlogging.ActionLogger();
      this.configuration = window.ut.tools.conceptmapper.defaultConfiguration;
      this.configure(window.ut.tools.conceptmapper.defaultConfiguration);
      this._init();
      this._logAction("application_started", {});
    }

    ConceptMapper.prototype.configure = function(newConfiguration) {
      var _this = this;
      return $.each(newConfiguration, function(id, settings) {
        _this.configuration["" + id].value = settings.value;
        switch (id) {
          case "actionlogging":
            _this.actionLogger.setLoggingTargetByName(settings.value);
            _this.actionLogger.setTarget(_this.meta.target);
            _this.actionLogger.setGenerator(_this.meta.generator);
            if (window.sessionId !== void 0) {
              return _this.actionLogger.setProvider({
                objectType: "dummy ILS",
                id: window.sessionId
              });
            }
            break;
          case "relations":
            return _this._initJsPlumb();
          case "textarea_concepts":
            return $("#ut_tools_conceptmapper_toolbar_list").find(".ut_tools_conceptmapper_conceptTextarea").each(function(id, template) {
              if (settings.value === "false") {
                return $(template).hide();
              } else {
                return $(template).show();
              }
            });
          case "combobox_concepts":
            return $("#ut_tools_conceptmapper_toolbar_list").find(".ut_tools_conceptmapper_conceptSelector").each(function(id, template) {
              if (settings.value === "false") {
                return $(template).hide();
              } else {
                return $(template).show();
              }
            });
        }
      });
    };

    ConceptMapper.prototype.consumeNotification = function(notification) {
      var _this = this;
      if (this.configuration.debug.value === "true") {
        console.log("ConceptMapper.consumeNotification: received notification: ");
        console.log(notification);
      }
      if (notification.type === "prompt" && this.configuration["show_prompts"].value === "true") {
        $("#ut_tools_conceptmapper_dialog").text(notification.content.text);
        $("#ut_tools_conceptmapper_dialog").dialog({
          title: "Notification",
          resizable: false,
          modal: true,
          autoOpen: false,
          height: 150,
          closeOnEscape: false,
          dialogClass: "ut_tools_conceptmapper_dialog",
          buttons: {
            "Ok": function() {
              return $("#ut_tools_conceptmapper_dialog").dialog("close");
            }
          }
        });
        $('#ut_tools_conceptmapper_dialog').dialog('open');
        return $('.ui-dialog :button').blur();
      } else if (notification.type === "configuration") {
        return this.configure(notification.content.configuration);
      } else {
        return console.log("ConceptMapper: Notification wasn't a 'prompt' or prompting is disabled; doing nothing.");
      }
    };

    ConceptMapper.prototype._logAction = function(verb, object) {
      if (this.isCurrentlyLogging && this.actionLogger) {
        return this.actionLogger.log(verb, object);
      }
    };

    ConceptMapper.prototype._init = function() {
      var _this = this;
      $("#ut_tools_conceptmapper_linkButton").click(function() {
        if (_this.mode === _this.LINK_MODE) {
          return _this.setMode(_this.NODE_MODE);
        } else {
          return _this.setMode(_this.LINK_MODE);
        }
      });
      this.storage = new ut.commons.persistency.FileStorage();
      $("#ut_tools_conceptmapper_store").click(this.saveConceptMap);
      $("#ut_tools_conceptmapper_retrieve").click(this.loadConceptMap);
      this._initDnD();
      this._initJsPlumb();
      if (window.notificationClient !== void 0) {
        window.notificationClient.register(this.notificationPremise, this.consumeNotification);
        return console.log("ConceptMapper.init: notificationClient found and registered.");
      } else {
        return console.log("ConceptMapper.init: notificationClient not found.");
      }
    };

    ConceptMapper.prototype.notificationPremise = function(notification) {
      return true;
    };

    ConceptMapper.prototype._initDnD = function() {
      var _this = this;
      $("#ut_tools_conceptmapper_toolbar .ut_tools_conceptmapper_concept").draggable({
        helper: "clone",
        cursor: "move",
        containment: "#ut_tools_conceptmapper_root"
      });
      $("#ut_tools_conceptmapper_map").bind('dragover', function(event) {
        return false;
      });
      $("#ut_tools_conceptmapper_map").droppable();
      $("#ut_tools_conceptmapper_map").bind('drop', function(event, ui) {
        if (ui && $(ui.draggable).hasClass("ut_tools_hypothesis_condition")) {
          return false;
        } else if (ui && $(ui.draggable).hasClass("ut_tools_conceptmapper_template")) {
          if (_this.configuration.debug.value === "true") {
            console.log("Concept template dropped. Clone and add to map.");
          }
          if ($(ui.draggable).hasClass("ut_tools_conceptmapper_conceptTextarea")) {
            _this.createConcept(ut.commons.utils.generateUUID(), $(ui.draggable).text(), ui.position.left, ui.position.top, "ut_tools_conceptmapper_conceptTextarea");
          } else if ($(ui.draggable).hasClass("ut_tools_conceptmapper_conceptSelector")) {
            _this.createConcept(ut.commons.utils.generateUUID(), $(ui.draggable).text(), ui.position.left, ui.position.top, "ut_tools_conceptmapper_conceptSelector");
          }
        } else if (event.originalEvent.dataTransfer) {
          if (_this.configuration.drop_external.value === "true") {
            _this.createConcept(ut.commons.utils.generateUUID(), event.originalEvent.dataTransfer.getData("Text"), event.originalEvent.clientX, event.originalEvent.clientY, "ut_tools_conceptmapper_conceptTextarea");
          }
        }
        return false;
      });
      $("#ut_tools_conceptmapper_trashcan").click(this.onClickHandlerTrashcan);
      $("#ut_tools_conceptmapper_trashcan").droppable({
        accept: ".ut_tools_conceptmapper_concept",
        drop: function(event, ui) {
          return _this.removeConcept(ui.draggable);
        }
      });
      $("#ut_tools_conceptmapper_notification").click(function() {
        var notificationConfiguration, notificationPrompt;
        notificationPrompt = {
          type: "prompt",
          content: {
            text: "The selection of pre-defined concepts has been changed."
          }
        };
        notificationConfiguration = {
          type: "configuration",
          content: {
            configuration: {
              concepts: {
                value: ["length", "mass", "time"]
              }
            }
          }
        };
        _this.consumeNotification(notificationPrompt);
        return _this.consumeNotification(notificationConfiguration);
      });
      return $("#ut_tools_conceptmapper_settings").click(function() {
        return new ut.tools.conceptmapper.ConfigDialog(_this.configuration, _this.configure);
      });
    };

    ConceptMapper.prototype._initJsPlumb = function() {
      var jsPlumbDefaults,
        _this = this;
      jsPlumbDefaults = {
        Connector: [
          "Bezier", {
            curviness: 500
          }
        ],
        ConnectorZIndex: 0,
        DragOptions: {
          cursor: "pointer",
          zIndex: 2000
        },
        PaintStyle: {
          strokeStyle: "#00b7cd",
          lineWidth: 4
        },
        EndpointStyle: {},
        Anchor: [
          "Perimeter", {
            shape: "Ellipse"
          }
        ],
        ConnectionOverlays: [
          [
            "Arrow", {
              location: 0.7
            }, {
              foldback: 0.7,
              fillStyle: "#00b7cd",
              width: 20
            }
          ], [
            "Label", {
              label: this.configuration.relations.value[0],
              location: 0.5,
              id: "label"
            }
          ]
        ],
        Detachable: false,
        Reattach: false
      };
      jsPlumb.importDefaults(jsPlumbDefaults);
      jsPlumb.setRenderMode(jsPlumb.SVG);
      jsPlumb.unbind("jsPlumbConnection");
      return jsPlumb.bind("jsPlumbConnection", function(event) {
        var object;
        event.connection.getOverlay("label").bind("click", _this.onClickHandlerConnectionLabel);
        object = {
          "objectType": "relation",
          "id": event.connection.id,
          "content": event.connection.getOverlay("label").getLabel(),
          "source": event.connection.sourceId,
          "target": event.connection.targetId
        };
        return _this._logAction("add", object);
      });
    };

    ConceptMapper.prototype.initConceptMapDropHandler = function() {
      $("#ut_tools_conceptmapper_map").bind('dragover', function(ev) {
        return false;
      });
      $("#ut_tools_conceptmapper_map").droppable();
      return $("#ut_tools_conceptmapper_map").bind('drop', function(event, ui) {
        if (ui && $(ui.draggable).hasClass("ut_tools_hypothesis_condition")) {
          return false;
        } else if (ui && $(ui.draggable).hasClass("ut_tools_conceptmapper_template")) {
          if (this.configuration.debug.value === "true") {
            console.log("Concept template dropped. Clone and add to map.");
          }
        } else if (event.originalEvent.dataTransfer) {
          createConcept(ut.commons.utils.generateUUID(), event.originalEvent.dataTransfer.getData("Text"), event.originalEvent.clientX, event.originalEvent.clientY, "ut_tools_conceptmapper_conceptTextarea");
        }
        return false;
      });
    };

    ConceptMapper.prototype.createConcept = function(id, conceptText, x, y, className) {
      var logObject, newConcept;
      newConcept = $("<div>");
      newConcept.attr('id', id);
      newConcept.addClass("ut_tools_conceptmapper_concept");
      newConcept.append($('<p/>').html(nl2br(conceptText)));
      jsPlumb.draggable(newConcept, {
        containment: "#ut_tools_conceptmapper_root",
        cursor: "move",
        revert: "invalid",
        iframeFix: true,
        delay: 50
      });
      newConcept.css('position', 'absolute');
      newConcept.css('top', y);
      newConcept.css('left', x);
      newConcept.addClass(className);
      if (className === "ut_tools_conceptmapper_conceptTextarea") {
        newConcept.click(this.onClickHandlerInjectTextarea);
      } else {
        newConcept.click(this.onClickHandlerInjectCombobox);
      }
      $("#ut_tools_conceptmapper_map").append(newConcept);
      if (this.mode === this.LINK_MODE) {
        this.setConceptLinkMode(newConcept);
      } else if (this.mode === this.LINK_MODE) {
        this.setConceptNodeMode(newConcept);
      }
      logObject = {
        "objectType": "concept",
        "id": id,
        "content": conceptText
      };
      return this._logAction("add", logObject);
    };

    ConceptMapper.prototype.onClickHandlerInjectTextarea = function(event) {
      var $p, textarea;
      if (this.mode === this.LINK_MODE) {
        return this.onClickEdgeHandler(event);
      } else if (!$(event.target).is("div")) {
        $p = $(event.target);
        textarea = $('<textarea/>').val($p.text());
        this.contentBeforeEdit = $p.text();
        textarea.autogrow();
        $p.replaceWith(textarea);
        textarea.on("blur", this.onBlurHandlerInjectParagraph);
        return textarea.focus();
      }
    };

    ConceptMapper.prototype.onClickHandlerInjectCombobox = function(event) {
      var $p, inputField;
      if (this.mode === this.LINK_MODE) {
        return this.onClickEdgeHandler(event);
      } else if (!$(event.target).is("div")) {
        $p = $(event.target);
        inputField = $('<input/>').val($p.text());
        this.contentBeforeEdit = $p.text();
        inputField.autocomplete({
          source: this.configuration.concepts.value,
          minLength: 0
        });
        $p.replaceWith(inputField);
        inputField.blur(this.onBlurHandlerInjectParagraph);
        inputField.autocomplete('search', '');
        return inputField.focus();
      }
    };

    ConceptMapper.prototype.onClickHandlerConnectionLabel = function(label) {
      var inputField;
      if ($("#" + label.canvas.id).find("input").length) {
        return $("#" + label.canvas.id).find("input").autocomplete('search', '');
      } else {
        this.editingLabel = label;
        inputField = $('<input/>').val(this.editingLabel.getLabel());
        this.labelBeforeEdit = this.editingLabel.getLabel();
        inputField.autocomplete({
          source: this.configuration.relations.value,
          minLength: 0
        });
        $("#" + label.canvas.id).text("");
        inputField.addClass("_jsPlumb_overlay");
        inputField.css("text-align", "left");
        inputField.css("font-size", "medium");
        $("#" + label.canvas.id).append(inputField);
        inputField.blur(this.onBlurHandlerInjectRelation);
        inputField.autocomplete('search', '');
        inputField.focus();
        return jsPlumb.repaintEverything();
      }
    };

    ConceptMapper.prototype.onBlurHandlerInjectRelation = function(event) {
      var newLabel, object;
      newLabel = nl2br($(event.target).val());
      this.editingLabel.setLabel(newLabel);
      $(event.target).parent().text(this.editingLabel.getLabel());
      $(event.target).remove();
      jsPlumb.repaintEverything();
      if (newLabel !== this.labelBeforeEdit) {
        object = {
          "objectType": "relation",
          "id": this.editingLabel.component.id,
          "content": newLabel
        };
        this._logAction("update", object);
      }
      this.labelBeforeEdit = "";
      return this.editingLabel = void 0;
    };

    ConceptMapper.prototype.onBlurHandlerInjectParagraph = function(event) {
      var inputElement, newContent, object, p;
      inputElement = $(event.target);
      newContent = nl2br(inputElement.val());
      p = $('<p/>').html(newContent);
      inputElement.replaceWith(p);
      jsPlumb.repaintEverything();
      if (newContent !== this.contentBeforeEdit) {
        object = {
          "objectType": "concept",
          "id": p.parent().attr("id"),
          "content": newContent
        };
        this._logAction("update", object);
      }
      return this.contentBeforeEdit = "";
    };

    ConceptMapper.prototype.removeConcept = function(concept) {
      var id,
        _this = this;
      id = $(concept).attr("id");
      this.deleteConnectionsBetween(id);
      return $(concept).fadeOut(300, function() {
        var object;
        $(concept).remove();
        object = {
          "objectType": "concept",
          "id": id
        };
        return _this._logAction("delete", object);
      });
    };

    ConceptMapper.prototype.onClickHandlerTrashcan = function() {
      var _this = this;
      $("#ut_tools_conceptmapper_dialog").text("Do you really want to delete all concepts and relations?");
      $("#ut_tools_conceptmapper_dialog").dialog({
        title: "Remove everything?",
        resizable: false,
        modal: true,
        autoOpen: false,
        height: 110,
        closeOnEscape: false,
        dialogClass: "ut_tools_conceptmapper_dialog",
        buttons: {
          "Yes": function() {
            _this.deleteAll();
            return $("#ut_tools_conceptmapper_dialog").dialog("close");
          },
          "No": function() {
            return $("#ut_tools_conceptmapper_dialog").dialog("close");
          }
        }
      });
      $('#ut_tools_conceptmapper_dialog').dialog('open');
      return $('.ui-dialog :button').blur();
    };

    ConceptMapper.prototype.deleteAll = function() {
      var _this = this;
      return $.each($("#ut_tools_conceptmapper_map .ut_tools_conceptmapper_concept"), function(index, concept) {
        return _this.removeConcept(concept);
      });
    };

    ConceptMapper.prototype.setMode = function(newMode) {
      var _this = this;
      if (newMode === this.mode) {

      } else {
        switch (newMode) {
          case this.NODE_MODE:
            $("#ut_tools_conceptmapper_map").find(".ut_tools_conceptmapper_concept").each(function(index, concept) {
              return _this.setConceptNodeMode(concept);
            });
            $(".ut_tools_conceptmapper_template").removeClass("ut_tools_conceptmapper_lowLight");
            $("#ut_tools_conceptmapper_linkButton").removeClass("pressedButton");
            $("#ut_tools_conceptmapper_linkButton").addClass("activeButton");
            jsPlumb.unmakeEverySource();
            jsPlumb.unmakeEveryTarget();
            $(this.sourceNode).removeClass("highlight_concept");
            $(this.targetNode).removeClass("highlight_concept");
            this.sourceNode = void 0;
            this.targetNode = void 0;
            return this.mode = newMode;
          case this.LINK_MODE:
            $("#ut_tools_conceptmapper_map").find(".ut_tools_conceptmapper_concept").each(function(index, concept) {
              return _this.setConceptLinkMode(concept);
            });
            $(".ut_tools_conceptmapper_template").addClass("ut_tools_conceptmapper_lowLight");
            $("#ut_tools_conceptmapper_map").find(".ut_tools_conceptmapper_concept").css("opacity", "1.0");
            $("#ut_tools_conceptmapper_linkButton").addClass("pressedButton");
            $("#ut_tools_conceptmapper_linkButton").removeClass("activeButton");
            return this.mode = newMode;
          default:
            return console.log("ConceptMapper.setMode: unrecognized mode " + newMode + " doing nothing.");
        }
      }
    };

    ConceptMapper.prototype.setConceptNodeMode = function(concept) {
      return $(concept).draggable("enable");
    };

    ConceptMapper.prototype.setConceptLinkMode = function(concept) {
      var _this = this;
      $(concept).draggable("disable");
      jsPlumb.makeSource(concept, {});
      return jsPlumb.makeTarget(concept, {
        dropOptions: {
          hoverClass: "jsPlumbHover"
        },
        beforeDrop: function(params) {
          if (params.sourceId === params.targetId) {
            if (_this.configuration.debug.value === "true") {
              console.log("Creating edges between same source and target is disallowed.");
            }
            return false;
          } else {
            if (_this.connectionExists(params.sourceId, params.targetId)) {
              if (_this.configuration.debug.value === "true") {
                console.log("An edge between concepts already exists -> delete it (instead of create a new one).");
              }
              _this.deleteConnectionsBetween(params.sourceId, params.targetId);
              return false;
            } else {
              if (_this.configuration.debug.value === "true") {
                console.log("All conditions met, create a new edge.");
              }
              return true;
            }
          }
        }
      });
    };

    ConceptMapper.prototype.onClickEdgeHandler = function(event) {
      var connection, sourceId, targetId;
      if (this.sourceNode === void 0) {
        this.sourceNode = event.currentTarget;
        $(this.sourceNode).toggleClass("highlight_concept");
      } else {
        if (event.currentTarget === this.sourceNode) {
          $(event.currentTarget).toggleClass("highlight_concept");
          this.sourceNode = void 0;
        } else {
          this.targetNode = event.currentTarget;
        }
      }
      if ((this.sourceNode !== void 0) && (this.targetNode !== void 0)) {
        sourceId = $(this.sourceNode).attr("id");
        targetId = $(this.targetNode).attr("id");
        if (this.connectionExists(sourceId, targetId)) {
          this.deleteConnectionsBetween(sourceId, targetId);
        } else {
          if (this.configuration.debug.value === "true") {
            console.log("Connection does not exist -> create.");
          }
          connection = jsPlumb.connect({
            source: sourceId,
            target: targetId
          });
        }
        $(this.sourceNode).removeClass("highlight_concept");
        $(this.targetNode).removeClass("highlight_concept");
        this.sourceNode = void 0;
        this.targetNode = void 0;
        return jsPlumb.repaintEverything();
      }
    };

    ConceptMapper.prototype.connectionExists = function(sourceId, targetId) {
      var existingConnections;
      existingConnections = jsPlumb.getConnections({
        source: sourceId,
        target: targetId
      });
      existingConnections = existingConnections.concat(jsPlumb.getConnections({
        source: targetId,
        target: sourceId
      }));
      return existingConnections.length > 0;
    };

    ConceptMapper.prototype.deleteConnectionsBetween = function(sourceId, targetId) {
      var connection, connections, object, _i, _len, _results;
      connections = jsPlumb.getConnections({
        source: sourceId,
        target: targetId
      });
      connections = connections.concat(jsPlumb.getConnections({
        source: targetId,
        target: sourceId
      }));
      _results = [];
      for (_i = 0, _len = connections.length; _i < _len; _i++) {
        connection = connections[_i];
        jsPlumb.detach(connection);
        object = {
          "objectType": "relation",
          "id": connection.id
        };
        _results.push(this._logAction("delete", object));
      }
      return _results;
    };

    ConceptMapper.prototype.getConceptMapAsJSon = function() {
      var conceptMap, concepts, connection, relation, relations, _i, _len, _ref;
      conceptMap = {};
      conceptMap.meta = this.meta;
      concepts = [];
      $.each($("#ut_tools_conceptmapper_map .ut_tools_conceptmapper_concept"), function(index, node) {
        var concept;
        concept = {};
        concept.x = $(node).offset().left;
        concept.y = $(node).offset().top;
        concept.content = $(node).find("p").text();
        concept.id = $(node).attr("id");
        if ($(node).hasClass("ut_tools_conceptmapper_conceptSelector")) {
          concept.type = "ut_tools_conceptmapper_conceptSelector";
        } else {
          concept.type = "ut_tools_conceptmapper_conceptTextarea";
        }
        return concepts.push(concept);
      });
      conceptMap.concepts = concepts;
      relations = [];
      _ref = jsPlumb.getConnections();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connection = _ref[_i];
        relation = {};
        relation.source = connection.sourceId;
        relation.target = connection.targetId;
        relation.id = connection.id;
        relation.content = connection.getOverlay("label").getLabel();
        relations.push(relation);
      }
      conceptMap.relations = relations;
      return conceptMap;
    };

    ConceptMapper.prototype.saveConceptMap = function() {
      var map, object;
      map = this.getConceptMapAsJSon();
      this.storage.storeAsFile(map, "conceptmap.json");
      object = {
        "objectType": "conceptMap",
        "content": map,
        "id": this.meta.target.id
      };
      return this._logAction("save", object);
    };

    ConceptMapper.prototype.loadConceptMap = function() {
      var _this = this;
      return this.storage.getJSonObjectFromDialog(function(errorMsg, jsonObject) {
        if (errorMsg) {
          return console.log("Error loading from file: " + errorMsg + ".");
        } else {
          if (jsonObject.meta.generator.displayName === "ut.tools.conceptmapper") {
            return _this.setConceptMapFromJSON(jsonObject);
          } else {
            return alert("Could not load file.\nIs it really a concept map file?");
          }
        }
      });
    };

    ConceptMapper.prototype.setConceptMapFromJSON = function(conceptMap) {
      var concept, connection, map, object, relation, _i, _j, _len, _len1, _ref, _ref1;
      this.isCurrentlyLogging = false;
      this.deleteAll();
      this.meta = conceptMap.meta;
      _ref = conceptMap.concepts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        concept = _ref[_i];
        this.createConcept(concept.id, concept.content, concept.x, concept.y, concept.type);
      }
      _ref1 = conceptMap.relations;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        relation = _ref1[_j];
        connection = jsPlumb.connect({
          source: relation.source,
          target: relation.target
        });
        connection.id = relation.id;
        connection.getOverlay("label").setLabel(relation.content);
      }
      this.isCurrentlyLogging = true;
      jsPlumb.repaintEverything();
      map = {
        "concepts": conceptMap.concepts,
        "relations": conceptMap.relations
      };
      object = {
        "objectType": "conceptMap",
        "content": map,
        "id": this.meta.target.id
      };
      return this._logAction("load", object);
    };

    return ConceptMapper;

  })();

}).call(this);

/*
//@ sourceMappingURL=ConceptMapper0.9.map
*/
